# 虚拟机容错

## 概述

该篇论文描述：通过在另一台服务器的备份虚拟机复制主虚拟机的状态，保证主备虚拟机状态一致，这样可以在主虚拟机出现错误，可以直接使备份虚拟机无缝衔接地代替主虚拟机，从而对外部隐藏了服务内部地故障。这就是虚拟机容错。

## 实现方法

论文中描述的思想就是：通过复制来容错。那么如何将主服务器的状态复制到备份服务器呢？

- 全量复制

  将主服务器的所有状态（CPU、内存、IO设备）的更改几乎连续地传送到备份服务器。因为需要发送所有状态，所以“复制”会占用大量的带宽。

- 增量复制—状态机方法

  将服务器建模为确定性状态机，通过从相同的顺序接收相同的输入请求来保持同步。由于大多数服务器或服务有一些不确定的操作，所以需要额外协调主备份服务器的同步。

  状态机采用物理机有一个问题：对于真实物理机而言，某些状态（时钟频率）很难确定。针对这个问题，VM的解决方案是将所有操作虚拟化，并在VM和物理机之间增加虚拟机管理程序，然后通过虚拟机管理程序让VM模拟成一个状态机运行。

## 系统架构

<img src="https://raw.githubusercontent.com/cold-bin/img-for-cold-bin-blog/master/img2/202309032155250.png" alt="image-20230903215458277" style="zoom:50%;" />



## 确定性重放

指的是：两个确定性状态的虚拟机从相同的初始状态开始，以相同的顺序接受相同的输入，最后得到相同的结果。

输入的范围：确定性输入（键盘输入、磁盘读取、网络数据包等）和非确定性输入（非确定性操作、非确定性事件）。

- 非确定性操作

  除了非确定性操作以外还有一些额外信息，需要记录到日志里

- 非确定性事件

  当事件发生时（如中断），会记录事件发生时执行的所有指令。重放时，备份虚拟机会在指令流的相同位置重放相同的事件。

## 容错协议

日志并不持久化到磁盘里，而是将日志实时地从主虚拟机通过日志通道传输到备份虚拟机，所以也需要为日志提供容错机制。

**输出规则：**若主虚拟机发生故障并由备份虚拟机接管后，备份虚拟机必须以一种与主虚拟机已经发送到外部的输出完全一致的方式运行。

容错协议规定：只要满足了输出规则，故障转移就不会丢失任何外部可见地状态或数据，客户端也不会注意到服务器的不一致。

特殊情况：如果主虚拟机在执行输出操作时就宕机（还没有执行完毕），而备份虚拟机没有收到相关日志。那么备份虚拟机在接管主虚拟机之后，就会出现输出不一致的情况。（也就是会漏掉或者形成不完整的一次输出），为了防止这样的情况发生，论 文里提到：在主虚拟机输出操作进行之前，需要先将日志传输到备份虚拟机上并且主虚拟机收到确认，主虚拟机才可以开始向外部输出数据。

但是这样的解决方案又导致了新的问题：

- 主虚拟机会等待备份虚拟机收到日志并发送确认的时间，也就是会导致客户端接收输出延迟一定的时间。当然其中等待确认的时间是不会阻塞的（延迟执行）

容错并不保证在故障的情况下，输出只产生一次，不同的故障会有不同的表现：

- 如果主虚拟机在收到确认之前发生故障，主虚拟机不会回复客户端，并且备份虚拟机的输出也会被集群丢弃。
- 如果主虚拟机在输出数据之后发生故障，备份虚拟机在接管后也会发送数据，客户端会收到两次输出，但是无关紧要，TCP会处理重复数据包；对于磁盘来说，输出两次覆盖相同的写入。

## 检测和响应故障

主虚拟机和备份虚拟机都可能发生故障，但是处理方式不同。

- 响应故障

  - 备份虚拟机故障：主虚拟机会停止向日志通道发送日志并正常执行
  - 主虚拟机故障：备份虚拟机会继续重放日志，当重放完成后成为新的主虚拟机。然后在集群中通知新的主虚拟机的MAC地址，以接管后续客户端发送的请求。
  - 无论哪台虚拟机发生故障，都会导致故障虚拟机下线，那么集群会自动地启动一台备份虚拟机来恢复冗余

- 检测故障

  - 虚拟机服务器之间通过UDP心跳包和日志管道流量来检测服务器是否存活

    因为有时钟中断的存在，可以认为在一定的时间内，日志管道没有流量，则可以认为服务器出现异常

  - 上面依赖于网络环境的检测手段，如果在网络环境出现故障（但是主备虚拟机都正常运行）时，就只会判定为故障。此时对于主虚拟机来说，无法检测到备份虚拟机，因此会停止向日志管道进行写入；而对于备份虚拟机而言，无法检测到主虚拟机，因此就会重放日志成为新的主虚拟机。这样集群中就有两个主虚拟机，因此产生"split brain"的情况。

## 容错基本设计和协议

### 启动和重新启动容错虚拟机

当我们需要重新启动新的备份虚拟机以恢复冗余时，新的备份虚拟机需要尽快地与主虚拟机状态同步。论文中提到：利用VMotion在远端机器上克隆主虚拟机，并建立日志通道，整个过程不到一秒。

而且，挑选新的备份虚拟机也会由集群服务挑选出最佳服务器，并将其复制为备份虚拟机。

### 管理日志通道

![image-20230904185458312](https://raw.githubusercontent.com/cold-bin/img-for-cold-bin-blog/master/img2/202309041900207.png)

主备虚拟机之间会有一个日志缓冲，主虚拟机向备份虚拟机同步日志的流程：

1. 如果发送缓冲区已满，则主虚拟机会阻塞，直到发送缓冲区可用。在这之前，主虚拟机无法响应客户端的请求；
2. 如果发送缓冲区未满，主虚拟机将产生的日志先放入发送缓冲区，并且发送缓冲区会尽快地将内容发送到日志通道；
3. 如果接收缓冲区已空，则备份虚拟机停止运行并阻塞等待；
4. 如果接收缓冲区非空，则备份虚拟机从日志通道里取出日志放入接收缓冲区，之后再从接收缓冲区中取出日志进行重放，并返回主虚拟机确认消息；

在上面的流程中，最大的问题是步骤一：如果发送缓冲区满了，就会导致主虚拟机不能响应外部请求。如何解决呢？论文中提到了：

- 在发送和确认日志的协议中，会发送附加信息来确定主虚拟机和备份虚拟机之间的实时执行延迟。如果备份出现了明显的延迟，那么就会反馈给主虚拟机并且使得主虚拟机的减少其CPU资源，以让主虚拟机执行慢下来匹配备份虚拟机的执行速度；如果备份的速度加快，就分配主虚拟机更多的CPU资源

### 磁盘IO实现问题

- 由于虚拟机的磁盘访问操作是并行非阻塞的，并且由DMA直接将数据搬运到虚拟机的内存中，因此同时访问同一内存页会有数据冲突。

  论文中的解决方案就是将所有冲突的操作串行化

- 磁盘操作与虚拟机中的应用程序或操作系统读取内存的同时又读取磁盘，内存和磁盘的数据可能会出现不一致的情况。如何解决？论文中提到了两种解决方案

  1. 同时读取内存页和磁盘页导致数据不一致的原因就是，内存里的页是脏页，没有将数据写回到磁盘上，也就导致了数据不一致的问题。所以，我们可以为作为磁盘操作⽬标的⻚⾯上临时设置⻚⾯保护。如果虚拟机访问的页是脏页，就调用trap并且暂停当前虚拟机运行，直到回写脏页到磁盘里

  2. 方式1有个很大的问题：需要额外更改页面的MMU保护，成本昂贵。所以采取`bounce buffer`方案。

     - 对于读操作：将指定数据读取到`bounce buffer`中，并且仅在IO完成交付时才将数据复制到客户端内存里。
   - 对于写操作：首先将要发送的数据复制到`bounce buffer`中，然后等待磁盘IO完成，再将`bounce buffer`中的数据写入
  
     上面的两种方案都是等待磁盘IO完成后，再进行读或写，所以会减缓磁盘操作速度。

- 当发生故障并且备份接管时，存在一些与主虚拟机上未完成的磁盘IO。如何解决？

  - 对于新升级的主虚拟机，重新发起挂起的IO。

### 网络IO实现问题

- 发送数据包的延迟带来了一些网络性能的挑战

  发送数据包之前需要将日志同步到备份服务器并接收到确认之后才能发送。

- 异步更新虚拟机的网络设备状态增加了不确定性

  异步更新无法确保所有更新都发生在主设备和备份设备指令流的同一点上。

## 共享磁盘与非共享磁盘

- 共享磁盘指的是主备共享磁盘。共享磁盘被视为主备虚拟机的外部，因此对共享磁盘的任何写入都被视为与外界的通信。因此只有主虚拟机才会时机写入磁盘，并且根据输出规则延迟写入共享磁盘（延迟指的是等待日志接收和确认的直接）

  而且共享磁盘能很好地处理掉”split brain“问题。

- 非共享磁盘指的是主备虚拟机拥有单独的虚拟磁盘。非共享存储也可以通过第三方服务器共享存储，来解决”split brain“问题。主虚拟机地磁盘写入无需等待延迟，因为磁盘写入并不会被记录到日志里。

  <img src="https://raw.githubusercontent.com/cold-bin/img-for-cold-bin-blog/master/img2/202309042036254.png" alt="image-20230904203643729" style="zoom:50%;" />

### 备份虚拟机上执行磁盘读

这样做就可以不用在日志通道中传输磁盘数据了，从而消除磁盘读取数据的记录，大大降低了通道流量。但是这种方式也存在着一些问题：

- 可能会减慢备份虚拟机的执行速度（执行所有磁盘IO）
- 执行额外的工作来处理失败的磁盘读取操作直到成功
